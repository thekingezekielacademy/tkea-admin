"use strict";(self.webpackChunkclient=self.webpackChunkclient||[]).push([[820],{820:(e,r,t)=>{t.r(r),t.d(r,{CourseScheduler:()=>i});var o=t(5608),s=t(7372);function c(e,r,t){return(r=function(e){var r=function(e){if("object"!=typeof e||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var t=r.call(e,"string");if("object"!=typeof t)return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==typeof r?r:r+""}(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}class i{constructor(){c(this,"notificationService",void 0),c(this,"checkInterval",null),this.notificationService=s.NotificationService.getInstance()}static getInstance(){return i.instance||(i.instance=new i),i.instance}startScheduler(){var e=this;this.checkInterval&&clearInterval(this.checkInterval),this.checkInterval=setInterval(function(){e.checkScheduledCourses()},3e5),this.checkScheduledCourses()}stopScheduler(){this.checkInterval&&(clearInterval(this.checkInterval),this.checkInterval=null)}async checkScheduledCourses(){try{const e=(new Date).toISOString(),r=await o.N.from("courses").select("*").eq("is_scheduled",!0).eq("status","scheduled").lte("scheduled_for",e),t=r.data,s=r.error;if(s)return void console.error("Error checking scheduled courses:",s);if(t&&t.length>0){console.log("Found ".concat(t.length," courses to publish"));for(const e of t)await this.publishCourse(e)}await this.checkUpcomingCourses()}catch(e){console.error("Error in checkScheduledCourses:",e)}}async publishCourse(e){try{const r=(await o.N.from("courses").update({status:"published",is_scheduled:!1,scheduled_for:null}).eq("id",e.id)).error;if(r)return void console.error("Error publishing course:",r);console.log('Course "'.concat(e.title,'" has been published')),await this.notifyCourseAvailable(e)}catch(e){console.error("Error publishing course:",e)}}async notifyCourseAvailable(e){try{JSON.parse(localStorage.getItem("course_notifications")||"[]").includes(e.id)&&await this.notificationService.sendCourseAvailableNotification(e.title,e.id)}catch(e){console.error("Error notifying course available:",e)}}async checkUpcomingCourses(){try{const e=new Date,r=new Date(e.getTime()+36e5),t=new Date(e.getTime()+864e5),s=await o.N.from("courses").select("*").eq("is_scheduled",!0).eq("status","scheduled").gte("scheduled_for",e.toISOString()).lte("scheduled_for",r.toISOString()),c=s.data,i=s.error;if(i)console.error("Error checking courses in one hour:",i);else if(c&&c.length>0)for(const e of c)await this.sendCourseReminder(e,1);const n=await o.N.from("courses").select("*").eq("is_scheduled",!0).eq("status","scheduled").gte("scheduled_for",e.toISOString()).lte("scheduled_for",t.toISOString()).gt("scheduled_for",r.toISOString()),a=n.data,l=n.error;if(l)console.error("Error checking courses in one day:",l);else if(a&&a.length>0)for(const r of a){const t=Math.floor((new Date(r.scheduled_for).getTime()-e.getTime())/36e5);await this.sendCourseReminder(r,t)}}catch(e){console.error("Error checking upcoming courses:",e)}}async sendCourseReminder(e,r){try{JSON.parse(localStorage.getItem("course_notifications")||"[]").includes(e.id)&&await this.notificationService.sendCourseReminderNotification(e.title,r,e.id)}catch(e){console.error("Error sending course reminder:",e)}}async notifyCourseScheduled(e,r,t){try{await this.notificationService.sendCourseScheduledNotification(e,r,t)}catch(e){console.error("Error notifying course scheduled:",e)}}async getScheduledCourses(){try{const e=await o.N.from("courses").select("*").eq("is_scheduled",!0).eq("status","scheduled").order("scheduled_for",{ascending:!0}),r=e.data,t=e.error;return t?(console.error("Error fetching scheduled courses:",t),[]):r||[]}catch(e){return console.error("Error fetching scheduled courses:",e),[]}}}c(i,"instance",void 0)}}]);